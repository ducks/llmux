order = 6
what = "File edits (unified diff preferred), verification commands, retry loops with error context"
why = "Hardest component due to LLM output unpredictability and rollback semantics; builds on workflow state for context"
how = "1. Edit format support (in priority order):\n   - Unified diff: parse @@ hunks, apply with fuzzy matching\n   - old/new pairs: exact match with whitespace normalization\n   - Full file replacement: path + content\n\n2. Diff application:\n   - Parse unified diff format\n   - For each hunk: find context lines, apply change\n   - Fuzzy matching: normalize whitespace, tolerate ±3 lines drift\n   - Generate backup before modification\n\n3. Verification:\n   - Run verify command (e.g., cargo clippy && cargo test)\n   - Capture exit code, stdout, stderr\n   - Success: exit 0\n   - Failure: rollback, optionally retry\n\n4. Retry loop (verify_retries):\n   - On verification failure:\n     a. Rollback changes (git checkout or restore backup)\n     b. Construct retry prompt with error context\n     c. Re-query the source step's role\n     d. Apply new edits, verify again\n   - Max retries from step config\n   - Timeout wrapper around full retry cycle\n\n5. Rollback strategies:\n   - Git: git checkout -- file or git stash\n   - Backup: restore from .llmux/backups/\n   - None: leave changes (for debugging)\n\n6. Source resolution:\n   - Parse `source = \"steps.consensus\"` \n   - Extract edits field from step output\n   - Validate edit format before applying\n\n7. Shell safety:\n   - Use array form for verify command if possible\n   - Or escape interpolated values with shell_escape filter\n"
backup = "old/new exact match only first; add unified diff parsing as enhancement"

[context]
inputs = "Step output containing edits, verify command template, retry config"
outputs = "ApplyResult: success/fail, applied files, verification output, retry attempts"
dependencies = ["workflow_engine"]
tests = "1. Test old/new replacement: exact match, whitespace normalized\n2. Test unified diff parsing: single hunk, multiple hunks, context lines\n3. Test fuzzy matching: find target with slight drift\n4. Test verification: success passes, failure triggers rollback\n5. Test retry loop: failure → rollback → re-query → reapply\n6. Test rollback: git strategy, backup strategy\n7. Test edge cases: file doesn't exist, old string not found\n8. Integration test: apply real diff, run real verify command\n"

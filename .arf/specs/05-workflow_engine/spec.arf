order = 5
what = "DAG execution, step sequencing, parallel groups, conditionals, for_each, validation"
why = "Orchestrates everything; needs templating for variable interpolation, roles for LLM steps"
how = "1. Workflow loader:\n   - Resolution order: .llmux/workflows/ → ~/.config/llmux/workflows/ → built-in\n   - Parse TOML, validate structure, return Workflow struct\n\n2. DAG construction:\n   - Build dependency graph from depends_on fields\n   - Detect cycles (error: circular dependency)\n   - Topological sort for execution order\n   - Identify parallelizable groups (no deps between them)\n\n3. Step executor:\n   - type = \"shell\": run command via tokio::process\n   - type = \"query\": call role_and_team_resolver\n   - type = \"apply\": defer to apply_and_verify component\n\n4. Conditional execution:\n   - Evaluate `if = \"expression\"` using template_engine\n   - Skip step if condition false, mark as skipped in result\n\n5. for_each iteration:\n   - Parse `for_each = \"steps.X.files\"` as template expression\n   - Evaluate to array, run step once per item\n   - Set `item` in context for each iteration\n   - Collect results as array\n\n6. Step groups:\n   - Parse [[groups]] sections\n   - Execute group steps according to group.parallel setting\n   - Expose group outputs via groups.{name}.outputs\n\n7. Workflow state:\n   - Track step results in HashMap<String, StepResult>\n   - Pass state to template engine for interpolation\n   - Support continue_on_error at step and workflow level\n\n8. Pre-run validation (llmux validate):\n   - All depends_on references valid\n   - All roles defined\n   - All templates parse\n   - No cycles\n   - Required args have values\n"
backup = "Sequential execution first (ignore depends_on parallelism), add DAG optimization later"

[context]
inputs = "Workflow TOML path or name, CLI args, team config"
outputs = "WorkflowResult: step results map, overall success/fail, timing"
dependencies = ["template_engine", "role_and_team_resolver"]
tests = "1. Test workflow loading: find by name, parse TOML\n2. Test DAG construction: correct order, cycle detection\n3. Test shell step: command runs, output captured\n4. Test query step: role resolved, backend called\n5. Test conditionals: step skipped when if = false\n6. Test for_each: iterates array, collects results\n7. Test groups: parallel execution, output aggregation\n8. Test validation: catch missing deps, undefined roles, template errors\n9. Integration test: run simple workflow end-to-end\n"
